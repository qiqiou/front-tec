# 字节飞书

## 一面

说一下登录的流程（提到了token）

token里面存什么；

你说token存用户信息是吧，那每次用户访问的时候后端都要去数据库比对是吗（是的吧）；

有什么坏处（每次都去数据库查找比对，可能比较麻烦费时费性能）

怎么改进（维护一个id缓存表格？token只存一种id，后端收到之后在缓存中比对id）

存id的话，怎么防止攻击者伪造一个和token相同的id，冒用用户向后端发起请求；

然后我自己聊到csrf，然后说一说什么是csrf（提到了攻击者会获取到页面cookie）；

怎么获取到另一个页面的cookie；

回到之前的伪造id问题，还可以怎么样防止？还可以使用一些加密算法和加密协议吧，比如https。

那说一下https协议流程（中间提到了判断证书有效性，提到了对称和非对称加密）

怎么判断https 证书是否有效？

为什么最后要选择对称加密来进行传输数据，而不使用最开始的非对称加密？

对称和非对称加密哪个安全性更高？

说一下修改state值之后，react一般会怎么处理，最后显示在页面上

说一下虚拟dom是什么？

如果用数据结构来表示的话，虚拟dom是一个什么结构

具体说一下新旧两棵虚拟dom树是如何比对更新的？

diff算法是按层比较的是吗，那如果我把一个节点的左孩子节点移动到右孩子节点的子节点，那么diff算法会判定为什么类型的改变，是移动还是增删？（增删吧，dom层级改变了）；

打开代码界面，一边写一边说（在这个地方聊了好多不记得了，反正了解原理应该就没问题）一般会使用什么来作为key值？index作为key值和其他值作为key值有什么区别

第一道题，给了一个父类Prent，要求实现一个子类Child（一开始使用了构造继承，和子类重写了一遍父类的原型方法。后来面试官说如果父类有很多原型属性和方法呢，我说那可以直接用原型链继承。）

第二道题，实现一个二叉树的颠倒，大概就四五分钟的时间，有点不太够，然后面试官直接问我思路，大概说一下遍历每个节点，将左右孩子变换位置。

然后问到一般有哪些遍历方法（先序，后序，中序，层序）；

层序遍历也就是广度优先搜索是吧（是的）

----------------

Javascript常见数据类型
如何判断数据的类型
对数组进行typeof返回什么
null和undefined有什么不同
如何判断NaN
ES6的新特性
箭头函数的特性
箭头函数和普通函数的区别
如何实现一个类
原型链是什么
JS数组map和set的区别
get和post的区别
JS用new方法创建实例时发生了什么
http和https的区别
为什么https的速度要慢一些
prototype和__proto__的区别

1. flex布局用过没，简单说下
2. 水平居中的方法
3. 讲一下BCF
4. 讲一下盒模型
5. 盒模型和怪异盒模型

1. flex布局用过没，简单说下
2. 水平居中的方法
3. 讲一下BCF
4. 讲一下盒模型
5. 盒模型和怪异盒模型



1. React兄弟组件之间如何传值
2. React状态提升
3. React单向数据流
4. React组件的优化
5. React的两种路由
6. SPA，如何实现
7. React 生命周期
8. React hooks
9. 常见状态码和请求头
10. 讲一下三次握手和四次挥手
11. 后端如何向前端传数据
12. 请求数据保存在报文的什么地方

1. git常用指令
2. git上传错误如何撤回
3. git如何上传新分支

1. koa了解吗
2. nodeJS常见api
3. koa和express的中间件有什么区别

1. 生成匹配的括号（不会，跳过）[剑指Offer II 085.生成匹配的括号](https://leetcode-cn.com/problems/IDBivT/)
2. 用promise实现sleep函数（不会，跳过）
3. 计算二叉树根结点到叶子结点的分支总和（写出来了，编译没通过）

-----------------



1.项目中有哪些你觉得很新颖很闪光的点? 

2.一道预编译的题目,看代码判断输出。 

从这道题引出了go对象,ao对象,还有一个vo对象(vo对象确实触及盲区了,直接说了不会哈哈哈。)最后问了作用域机制并且最后问js在底层是如何能实现从作用域链往上查找变量 

2.一道原型链的题,挺简单。 

3.promise题目 看代码判断输出 

4.一道vue题目, 一个组件模板,组件有三个响应式数据,模板中用到了两个。然后三个数据分别++,最后问组件收到几次通知,最后重渲染几次。题目本身简单,但是从这道题引出了vue的底层响应式原理(把依赖收集/派发更新/异步更新队列都详细阐述了一遍。) 

5.为什么vue的异步队列放在微任务队列而不是宏任务队列? 

6.阐述vue的diff[算法]()

阐述完后,又就子节点列表使用双指针对比问了一些细节问题 

7.计网部分 

\1) 谈谈对http缓存协议的理解 

从http1.0开始到http1.1, 把expires,cache-control,last-modified,Etag都详细阐述了一遍并且指出来各种缓存字段的缺点 

2)Etag字段如何根据资源内容生成唯一资源编号 

3)谈谈https协议的原理 

这题本身是八股, 简单。但是问了浏览器在接受证书时是如何判断证书没有被篡改过(知识盲区) 

8.[算法]()

大概意思是生成一个可能会有无限纬度的数组 

，数组的最里层是一个数组,数组每一项是一个初始值.

------------------

请介绍一下自己 

说一下你在做前端项目中的出现的问题，是怎么解决的？（最怕的一个问题，可能就是项目不熟吧） 

看到你项目里面用到了`jsonp`，说说`jsonp`是怎么请求到数据的？ 

跨域请求的方式还有哪些呢？有没有尝试过？ 

图片懒加载和虚拟列表怎么做的？（项目里面写了） 

在做项目的时候，有没有对前端安全有所学习呢？（估计是想问`XSS`和`CSRF`） 

看到你用到了登录，`token`或者`cookie`是存放在哪里的呢？如果是想实现15天免登录怎么做，`token`或者`cookie`放在那里？ 

说说`HTTP2`相对于`HTTP1`有哪些变化，（这个是唯一的八股，呜呜呜~），我在回答里面有服务器推送，面试官问我如果`HTTP1`要实现服务器推送应该怎么做呢？（不了解，直接傻了~） 

说一下`promise`和`async/await`，分别是怎么捕获错误的？如果把`promise`写在`try/catch`里面会捕获到错误吗？



1. 三数之和，（这个题目还没刷，说了一下思路，写了一点不会了） 
2. 判断[链表](https://acm.nowcoder.com/jump/super-jump/word?word=链表)是否成环，怎么降低空间复杂度

----------------

1. TCP为啥是安全的？
2. 4次挥手的过程，为什么不是3次？
3. 等待2msl是为了什么？
4. https的特点，对称加密和非对称加密的特点。
5. 线程池用过吗，怎么用的？
6. MySQL优化了解吗？



1. B+树和B树的区别。
2. 200W数据放数据库中层数多高？
3. 数据库加锁的系统调用是什么？
4. 行锁是在什么情况下出现？
5. TCP慢开始的过程，初始的时候是发的几个报文；
6. 慢开始什么时候结束？
7. 快重传出现的情况？
8. close_wait是哪边的状态？
9. ConcurrentHashMap说一下；
10. volatile了解吗？volatile使其他线程数据失效的汇编指令是哪个？

做题：[LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)（✔）



1. MySQL索引在你的项目中是怎么进行优化的，举一个具体的例子。
2. 联合索引是怎么存放在磁盘上的？
3. mybatis如何实现只写接口和mapper就能进行数据库的查询的？
4. nginx的多线程还是多进程，是如何实现多进程监控一个端口的，抢占模式是怎么实现的？

做题（30min）：实现一个图书馆类，包含存书和搜索书籍两个功能，要求搜索的时候按照最左匹配原则找出所有满足的书籍。（时间不够，写了一半，面试官让说一下思路）



------------------



围绕项目提了5、6个问题 

前后端分离的理解？

前端是怎么打包的

登录这块的前后端是怎么实现的

跳转页面之后服务端怎么知道这个用户跟前一个是同一个的

token前端是怎么传给后端的，是放在url后面吗

如果是get请求后面不安全的话，要怎么优化呢

用户登录之后关闭网页再次打开页面，这个登录状态还会在吗

设置cookie的过期时间是由前端设置的吗？

交互的时候有没有遇到跨域的问题

vue是怎么启动

npm run sever执行的是什么

v-show和v-if的区别

**代码题**，3个盒子，中间盒子定长等宽，左右两个盒子自动填充宽度

选择器的优先级：行内样式（最高级）>id选择器>类选择器>标签选择器

**代码题**：计算函数的执行时间（我是在函数内获取当前时间戳，调用了这个函数后再获取一次时间戳，但是面试官提示还存在函数增强，当时太紧张，没思考出来，然后面试官换了一个题）

**代码题**：字符串压缩，把‘aaaabbccc’转化为'4a2b3c'



### **17.Js有哪些数据类型**

参考这篇[文章](https://link.zhihu.com/?target=https%3A//jingyan.baidu.com/article/4ae03de333f1a07fff9e6b96.html)

### **18.为什么要使用Vue**

vue的优势:轻量级框架、简单易学、双向数据绑定、组件化、数据和结构的分离、虚拟DOM、运行速度快。

### **19.Vue的双向数据绑定底层实现原理（用js）**

参考这篇[Vue的双向绑定原理和实现](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/libin-1/p/6893712.html)

### **20.什么是设计模式**

参考这篇[什么是设计模式](https://zhuanlan.zhihu.com/p/28901918)

### **21.什么是事件循环**

参考这篇[深入理解JavaScript的事件循环（Event Loop）](https://link.zhihu.com/?target=https%3A//blog.csdn.net/tzllxya/article/details/92674042)

### **22.什么是冒泡事件**

参考这篇[什么是冒泡事件?](https://link.zhihu.com/?target=https%3A//blog.csdn.net/ligenyingsr/article/details/6129908)



自我介绍

看代码写结果

```
 var val = 10  let a = function(){   console.log(this.val)  }  a.prototype.val = 9  val = 3  a();  let b = new a();  console.log(b.val)
```

问了a()的执行环境，是谁调用的，聊了原型原型链，作用域啥的

事件循环机制

setTimeout执行

进程和线程

编程题：

1、写一个函数，给了需要执行的函数，间隔时间，执行次数，每隔一段时间执行需要执行的函数，执行n次，大概意思就是这样

```
 function job(){      return function(){        }  }  let myTodo = job(30000, 5)  myTodo('alert')
```

用了setInterval来写，面试官看了应该是没什么问题，然后问我能不能用setTimeout，讲一下setTimeout的思路，我说的是promise，但好像不太行跟他讲了下原因为什么不行，然后他给了个递归的思路

2、问假设有不限个数，但是范围都是1-100之间，怎么样能够最快得到[排序]()结果

讲一下都有什么[排序]()，讲了一下正常开发过程中常用的sort，快排，冒泡，选择啥的

-----------------



讲一讲微前端有哪些实现策略 

讲一讲你之前的项目采取了哪些安全策略？ 讲一讲 XSS 攻击和 CSRF 攻击 

实现`三栏布局`, 用`float + BFC`和`flex`两种方式 

实现单行文本在父元素中不换行, 溢出部分变成省略号形式

[复制代码](#)

```
white-space``: ``nowrap``;``overflow``: ``hidden``;``text-``overflow``: ellipsis;
```

`防抖, 节流`的定义及二者区别， 手写防抖的实现 

讲一讲`浏览器缓存机制`， 涉及到哪些 http 报文字段？ 

讲一讲 js `事件循环机制`， 列举宏任务, 微任务有哪些？看代码说结果 

[算法]()： 给定一个字符串, 里面只有`a`, `b`, `c`三种字符， 要求从头遍历到尾， 去掉所有的 `b`, 和所有的 `ac`



1.实现一个深拷贝（用的递归） 
基本实现了，但是问我怎么处理对象，date类型我没答上来 

2.这道题我忘了 

3.实现一个promise.all 
promise的实现是背了忘，忘了背，这回正好又不会，我跳过了 

4.实现大数想加 
不让用bigint，最后还是用最基础的循环相加实现了 

5，BFC是什么，应用场景，如何实现 

6.flex布局，父元素和子元素分别有哪些属性 
父答出来了，子（我当时是懵的，因为我印象中子没什么可设置的，下来查了资料，！！！恍然大悟，给忘了）

7.defer和async 
没答出来，下来查了才知道这个 

8.webpack 
不会，因为一直用cli脚手架，具体不清楚了就 

9.for in和for of的区别



1.设计一个结构，使得可以存贮数据，并删除数据（get，set），给定最大可存储量，如果超出最大量则删掉最低优先级的 
2.爬楼梯，一步两步，怕x级有多少趴法 



作者：ReveFestival
链接：https://www.nowcoder.com/discuss/930091?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



1. map和obj的区别
   对相同操作他们的性能有差异吗？

   > map频繁增删键值对的场景下表现更好，不过要解释清楚似乎有点困难，还好面试官没接着深究了

2. Hooks怎么封装一个移动端的滑动轮播插件？
   Hooks怎么封装这里的手势逻辑？

   > 先封装一个useDraggable的Hooks片段，
   > useDraggable在Mounted时会监听down move up三个事件，同时useRef存住目标元素DOM节点，useState加一个判断是否正在拖动的状态；down事件会使拖动状态为true；move事件触发时判断若正在拖动，则把鼠标的位置赋给DOM；down事件会使拖动状态为false...

3. 手写一个Promise.all方法

4. 手写一个Promise.all方法，但是存在最大并发数量限制

5. async await的原理是什么？

   > 一个async函数，其实是一个生成器函数，await其实是yield
   > 生成器函数执行生成迭代器，
   > 迭代器每next()一次就会生成一个值
   > next(args)还可以传值给生成器内部，在外部给yield出的Promise绑定then并拿到成功值，再传回内部。

   [复制代码](#)

   `function` `*gen(){``  ``const num1 = yield fn(1);``  ``console.log(num1);``  ``const num2 = yield fn(num1);``  ``console.log(num2);``}``(``function` `autoGen(genFn){``  ``const gen = genFn();``  ``return` `new` `Promise(resolve=>{``   ``go()``   ``function` `go(arg){``     ``res = gen.next(arg)``     ``const {value, done} = res;``     ``if``(done) resolve(``'yes'``)``     ``else``{``      ``value.then((data)=>{``        ``go(data)``      ``})``     ``}``   ``}` `  ``})``})(gen).then(console.log)`

1. 你对虚拟dom有什么理解？为什么要用虚拟DOM？

   > 能缓存批量操作，减少频繁改动DOM，又能复用节点。。

   但是实际情况下，页面元素不仅较少，而且也没那么多对同一个DOM元素频繁改动的场景，而且复用的得到那一点性能也没diff开销大，那虚拟DOM到底有什么意义？ 

   你对VDOM的理解只是“别人说用我就用”，而不是去思考为什么要用，是这样吗？

1. addEventListener第三个参数

   [复制代码](#)

   `{`` ``capture: ``false``, `` ``once: ``false``, ``// 调用一次后就自动销毁监听器`` ``passive: ``false` `// 若为真，保证回调内永远不会阻止默认事件（调用preventDefault）``}`

   > 只要用户输入事件在内核线程执行逻辑，且内核线程在忙，则必然无法得到响应。
   > 大部分的输入事件都和页面元素有关，监听器触发的回调代码必须在内核（V8运行在内核）线程中执行。
   > 但是手势输入事件（滑动 捏合）能够在已经渲染好的快照上处理，而不需要进入内核线程执行
   > 再但是，手势输入事件是由连续的 普通输入事件 组成的，普通的输入事件可能会被内部的`preventDefault`来阻止掉事件后续的默认行为，在将回调放入内核线程执行前，浏览器根本不知道回调内有没有阻止后续默认行为，也就无法进行优化

1. webpack如何实现代码拆分——打包后的dist中，为什么你的vue项目代码拆分很少，而react项目代码拆分很多？

   > 戳到软肋了，真不会

2. 你有什么避免hooks重渲染的最佳实践吗？

   > memo包裹组件，再为组件传入useCallback后的函数

   你意思是传入内联对象和函数开销都很大？意思是平常开发都不准用内联对象和函数？

3. 线上代码报错位置，怎么还原到开发环境下的原始报错位置？

   > 调个包就行了
   > ...
   > npm source-map 库进行错误定位。SourceMapConsumer 构造函数传入.js.map文件，并为实例传入行号列号就能得到映射后的源行号列号

4. 说说你用了哪些页面媒体查询方案

   > css @media ...

   还有别的吗？

   > 我真不知道了，但面试官也没有接着解释答案，网上也搜不太到

## 二面

第一题 
给你一个数组，有正负有0的，让你找出所有的，三个数相加为0的情况，且要去重 

第二题，给两个逆向数字，求他们相加后的逆向 
比如[4,5,6],[1,2,3] 
就是654+321=975 
返回[5,7,9] 



- 讲一讲微前端有哪几种实现策略？ 你之前实习的项目用的是什么策略？ 讲讲`monorepo`是什么

- 用 `<iframe>` 实现微前端， 有什么缺陷？ 路由和样式受到限制， 不能正常使用浏览器的后退/前进按钮， 那你们的项目是如何解决这一点的？ 答： 我们之前的项目是在微前端落地页又重新实现了一遍 Tab 组件， 进入一个微前端子工程， 就在页面上新增一个重新实现的 Tab 页， 用户通过切换 Tab 页的方式就不用点击后退／前进了．相当于多挂载一个 iframe， 因此性能开销很大， 我们之前的项目限制同时最多打开 10 个 Tab 页。 问： 你们之前的项目为什么这么做？ 理由是什么？是一开始就定下来这样做的吗？ 答： 不知道...一开始就是这么定的

  > 补充: `<iframe>` 元素本身的优缺点:
  > 优点: 可解决加载缓慢的第三方内容, 如页面上的图标, 广告等; 可并行加载脚本; 可利用自定义 sandbox 安全沙箱属性值控制其脚本执行, 获取本地存储, 跨域, 控制父元素 DOM 等行为, 更加安全;
  > 缺点: 阻塞`onload`事件; `<iframe>`元素无语义; 加载`<iframe>`元素需要时间, 即使内容为空.
  > [qiankun 为什么不用 iframe](https://www.yuque.com/kuitos/gky7yw/gesexv)
  > [garfish 为什么不用 iframe](https://zhuanlan.zhihu.com/p/415900889?utm_source=wechat_session&utm_medium=social&utm_oi=791323202327580672&utm_campaign=shareopn)

- （前三个问题问了半个小时）讲一讲跨域的原理， 为什么要跨域，常见的跨域实现方式， 手写`JSONP`实现

- 问一个`react hooks`题目， 假如有一个这样的组件：

[复制代码](#)

```
import` `{ FC, useState, useEffect } from ``'react'``;``import` `{ fetchCount } from ``'./service'``;` `const` `Demo: FC = () => {``  ``const` `[count, setCount] = useState(0);``  ``// 组件初始化时执行该函数， 向后端请求 count 的初始值``  ``const` `init = async () => {``    ``const` `value = await fetchCount();``    ``setCount(value);``  ``}` `  ``useEffect(() => {``    ``init();``  ``}, []);` `  ``// return ...;``}
```

现已知上述代码不安全， 如果第 5 行执行时间过长， 在第 5 行阻塞时， 页面被用户手动关闭了， 再执行第 6 行时会报 warning， 请问如何改造代码， 使`setCount`变得安全？

> 用`useRef`记录组件的生存状态， 在 useEffect 当中写 return 函数， 组件卸载时将 useRef 记录的状态转为 false

- 手撕代码： 实现一个`get(0).add(1).sub(2).mul(3)`， 返回 -3; 我用 ts 定义包装类写的 
- [算法]()： 一个给字符串部分去重的题目, 具体要求忘记了, 不过在[牛客]()其他[面经]()看到过 

> 二面同样因为时间久远记不清几道题了。 



-------------

作者：Seauning
链接：https://www.nowcoder.com/discuss/932844
来源：牛客网



1. 上一问提到了学习框架，然后开始问我关于 Vue 中有没有什么优化的地方

2. 说了一个关于 Watcher 的优化，防止重复加入 Watcher 重复执行回调 (忘了可以说虚拟 DOM 呆，因为一开始也说了减少 DOM 操作，没有 GET 到面试官)

3. 场景题，二维码登录，问具体逻辑

4. 基于二维码登录有没有什么可以健壮整个登录系统的地方

5. 一开始说了恶意请求攻击，然后讲讲怎么防止

6. 又问我还有没有其他的，边引导我，接着就是说了些关于前后端交互，多次显示二维码方面的优化

   之前没有做过二维码登录，关于三端之间的交互逻辑了解的也不是非常多，答的不好，面试官也没多

   为难我，大体聊了十几 min 这里。

   后来复盘看了下相关的逻辑，二维码登录不仅可以从恶意请求攻击方面优化。还有 PC 端的二维码过期时的二维码刷新，二维码刷新可以考虑用户

   体验又或是服务器压力，每隔一段时间自动刷新会对服务器造成额外的压力，可以通过在移动端提示二维码失效告诉用户请重新刷新二维码的方式

   让用户手动点击刷新按钮进行刷新，这样也可以减少二维码图片的请求。另外二维码的图片也可以不在服务器生成，pc 端可以向服务器请求一个二维码的信息，

   比如 `附带二维码唯一 id 的完整的访问链接` 或者 `只是一个二维码的 id` 及 特定参数，特定参数可以包括二维码过期时间等，然后在 PC 端由一些库依据 二维码 id 或 完整的访问链接 生成二维码，这样也可以减少请求和响应的报文的体积。

   当然这些也都能由服务器生成，这样 PC 端部分只需要负责展示二维码，刷新二维码，轮询 / 接收服务器推送二维码的状态 即可。

   移动端则扫描二维码从中提取出 二维码的 id / 访问链接，再调用服务端提供的 api 将 是否确认登陆的状态 以及 二维码的唯一标识发送给服务端，

   这样服务端便可以通过这些信息改变用户的登录态，以及二维码的状态 (待扫码 / 已扫码 / 已确认 / 已超时过期失效)。

   这部分的优化还是挺多的，只是自己了解的太少了，平时业务接触的太少了，后续重写项目时可以借鉴相应的思想。

   参考资料：

   [扫码登录](https://xw.qq.com/cmsid/20210907A0D5E400)

   [二维码扫描登录的原理](https://baijiahao.baidu.com/s?id=1720540594523117642&wfr=spider&for=pc)

7. 从输入一个 URL 到浏览器显示整个过程 (没有全部讲完，边将边往深的挖)

8. DNS 解析过程

9. HTTPS 握手过程，这部分和中间人攻击讲的不是很好有点忘了

10. 中间人攻击

11. 做题

12. LRU 缓存策略，set & get 方法，set 添加对象 {id, object} ，每个对象有一个 x 的过期时间，过期了自动删除，

    set & get 可以更新过期时间，并且缓存有最大容量，当缓存中的对象数超过最大容量后，删除最久没有

    get & set 的对象。

    **关于这题忘记了 hashmap 的特性，面试官问 map 是不是有序的，这个是有序的，因为 hashmap 会记录这个 `不存在的键值对` set 时的顺序**
    **而在 set 完之后，之后每次 set 不会更新它的顺序，而 LRU 缓存是最近最久未使用，所以在每次 get & set 时需要 delete**
    **在 map 上的相应的键，然后再 set 回去，这样优先级就更新了。还有就是关于 x 时间后过期，一开始想着在每次 set 的时候添加这个键**
    **值对的存活时间，并在之后 get 时判断一下是否过期，实际上这并没有满足 x 时间后过期。之后改成了 setTimeout ，可能是因为大脑太乱**
    **了吧，如果用 setTimeout 可能会涉及到内存泄漏的问题，这方面也需要处理很多，也没有写好，之后差不多就过了。**

[复制代码](#)

```
class Cache {`` ``constructor(n) {``  ``this``.cache = ``new` `Map();``  ``this``.timers = ``new` `Map();``  ``this``.size = n;``  ``this``.lifetime = 1000;`` ``}` ` ``get (id) {``  ``if` `(!``this``.cache.has(id)) ``return` `null``; ``// 不存在了直接返回` `  ``const object = ``this``.cache.get(id);   ``// 拿到旧的 object` `  ``clearTimeout(``this``.timers.get(id));   ``// 存在，删除旧的` `  ``this``.cache.``delete``(id);        ``// 存在，删除旧的` `  ``this``.setTimer(id, ``this``.lifetime);   ``// 从新设置定时器` `  ``this``.cache.set(id, object);      ``// 往缓存中重新添加` `  ``return` `object;`` ``}` ` ``set (id, object) {``  ``if` `(``this``.cache.has(id)) {``   ``clearTimeout(``this``.timers.get(id)); ``// 删除旧的``   ``this``.cache.``delete``(id);      ``// 删除旧的``  ``}` `  ``this``.cache.set(id, object);   ``// 设置新的``  ``this``.setTimer(id, ``this``.lifetime); ``// 设置新的` `  ``if` `(``this``.cache.size > ``this``.size) {   ``// 超出了最大容量``   ``const _id = ``this``.cache.keys().next().value;``   ``clearTimeout(``this``.timers.get(_id)); ``// 删除旧的``   ``this``.cache.``delete``(_id);       ``// 删除头部移除的对象``  ``}`` ``}` ` ``setTimer (id, lifetime) {``  ``this``.timers.set(id, setTimeout(() => {``   ``this``.cache.``delete``(id);``  ``}, lifetime))`` ``}` `}
```

1. 发布订阅
2. 最长无重复子串
3. 反问



2、说说你了解的React Hook 

3、你都用过哪些Hook 

4、你知道Hook为啥官方建议不要在hook使用条件语句么 

5、React的整个更新过程可以聊一聊么（Schedule，setState过程） 

6、代码：使用hook的写法监听浏览器视窗大小，并展示在页面上 

7、了解CDN么？原理是什么？ 

8、你知道如何防止DNS域名污染么？ 

9、HTTPS中的CA证书是做什么的 

10、代码：手写一个发布定义类，其中还要多额外实现一个once方法（被发布一次就会删除订阅）



 

## 三面

觉得自己一二面怎么样

事件循环机制

防抖节流

为什么cdn字体会发生跨域（项目相关）

说说TCP和UDP

口述编程题

有10个只有两面有数字的骰子，数字范围是1-6，如果能够凑齐同一面都是一样数字的话，需要翻几次面可以同一面都是一样数字，如果不行返回-1



作者：追_
链接：https://www.nowcoder.com/discuss/937371?channel=-1&source_id=community_index_nctrack
来源：牛客网



## 场景题

- 输入一个字符数组， 转化为如下格式

  [复制代码](#)

  `//input ["a","b","c","d","e","f","g"]` `//output {"a":{"b":{"c":{"d":{"e":{"f":"g"}}}}}}``//一开始很懵, 后面思路起来想到应该从后往前推就做出来了``function` `handler(arr){``  ``const len = arr.length;``  ``let prev = {``    ``[arr[len-2]]:arr[len-1]``  ``}``  ``for``(let i=len-3;i>=0;i--){``    ``prev = {``      ``[arr[i]]:prev``    ``}``  ``}``  ``return` `prev``}`

- 如何获取页面中出现的所有dom元素的标签类型

  得到一个数组，数组的每一项是一个标签名

  [复制代码](#)

  `//其实只要知道如何获取页面中所有元素就能做出来, 通过document.querySelectorAll("*")获取``const all = Array.from(document.querySelectorAll(``"*"``));``const hash = {};``const res = [];``all.forEach(it=>{``  ``if``(!hash[it.tagName]){``    ``res.push(it.tagName);``    ``hash[it.tagName] = ``true``;``  ``}``})``console.log(res)`

## 对框架的理解

因为我是vue2和react都学过, 在简历里面都写了，所以两个框架都问到了。

#### 说说vue和react的异同

早就预料到可能会问这个, 因此之前自己有总结过: 

相同点:

- 核心库都只关注ui层面的问题解决，路由/状态管理都由其他库处理。

- 都使用了虚拟dom来提高重渲染效率。

- 都采用了组件化思想，将应用中不同功能抽象成一个组件，提高了代码复用性。

- 都能进行跨平台，react使用react native，vue使用weex

- 都有自己的构建工具:

  vue: vue-cli

  react: create-react-app

不同点:

- 最大的不同是组件的编写方式

  vue推荐使用类似于常规html模板的方式来编写组件, 基于vue强大的指令系统来进行数据的绑定和添加事件监听。在vue中，一个组件就是一个.vue文件。

  而react中采用jsx语法，每一个jsx表达式都是一个react元素. 在react中，一个组件本质就是一个函数或者一个类。

- 虚拟dom渲染效率方面

  由于vue对数据进行了劫持，因此每一个响应式数据都能进行依赖跟踪。当组件重新渲染时，不必重新渲染它的整个子组件树，而是只渲染应该重渲染的子组件。

  在react中，一旦组件状态变化导致重渲染后，其整个子组件树都会默认重新渲染。可以通过pureComponent或者shouldComponentUpdate来进行优化。

- 响应式方面

  vue由于使用defineProperty或者proxy, 能对数据进行劫持。因此只要修改了响应式数据本身就能导致组件的重渲染。

  而在react中，并没有对数据本身进行劫持，需要手动调用setState才能触发组件的重渲染。并且react强调使用不可变数据，即每次更改状态时，新状态的引用必须和旧状态不同。如果说没有使用不可变数据并且又在组件内使用了pureComponent或者shouldComponentUpdate进行优化，可能会导致状态变化组件没有重新渲染。

- 高阶组件

  react中存在HOC(高阶组件)的概念，因为react中的每一个组件本质都是一个函数或者类，都是编写在js代码中。因此可以轻松的实现高阶组件来对组件进行扩展。而vue采用模板编译的方式编写组件，无法使用HOC, 通常通过mixin来扩展组件.

- 指令系统

  vue有一套强大的指令系统并且支持自定义指令来封装一些功能。

  react则更偏向底层，使用javascript原生代码进行封装功能。

#### 说说vue3的composition api 和 react hook的区别？

这个也算是预判到了, 当时想着如果问了vue和react的对比很有可能会问这个. 之前也做过总结:

react:

由于react没有实现真正的数据双向绑定即没有对数据进行劫持，react是依靠hook的调用顺序来知道重渲染时，本次的state对应于哪一个useState hook。因此在react中使用hook有如下要求:

- 不能在循环/判断/嵌套函数内使用hook 
- 总是确保hook出现在函数组件的最顶部 
- 对于一些hook如useEffect, useMemo, useCallBack, 必须手动注册依赖项。 

而在vue中, 基于vue的响应式系统，composiiton api在调用时可以不用考虑顺序并且能使用在判断/循环/内部函数中。并且由于vue的响应式数据会自动收集依赖，因此使用一些composiiton api如computed以及watchEffect时无需手动注册依赖。

后面基本是一些小的问题比如:

- vue中的scoped style是如何实现作用域样式以及为什么vue不使用css module来实现作用域？ 
- 为什么vue要将传递给子组件的属性分为props和attrs?(这个不会,把props和attrs?(这个不会,把props和attrs的区别说了一下) 
- 说说最近学习的新技术？ 

 我直接坦白了最近都在准备面试没有学新技术, 然后面试官问准备面试过程有哪些提升？

我回答了对vue的响应式系统原理理解更深入了以及对http协议了解更多了, 然后面试官让我说说这些提升在具体中的项目的应用有哪些？

说了this.$nextTick和vue的异步更新队列在项目中的应用。



------------------



- 你之前的部门用的微前端什么方案（和二面一样的问题） 
- 讲讲 js 原型链， 手写用`Object.create()`实现继承的代码（不是直接实现继承， 而是实现一个继承功能的函数， 因此绕了个弯） 

[复制代码](#)

```
function` `Parent(data) {``  ``this``.data = data;``}` `Parent.prototype.foo = ``function``() {``  ``console.log(``this``.data);``}` `function` `inherit(Foo) {``  ``// write code here, return Child class constructor``}` `var` `child = ``new` `(inherit(Parent))(123);``child.foo(); ``// -> 123
```

答案: 

[复制代码](#)

```
function` `inherit(Foo) {`` ``var` `Child = ``function` `(data) {``  ``Parent.call(``this``, data);`` ``};`` ``Child.prototype = Object.create(Foo.prototype);`` ``return` `Child;``}
```

- Webpack 打包原理； 你都知道哪些`plugin`， 讲讲常见的`plugin`的功能和原理； 

- 问了一堆 babel 的配置， 完全听不懂... 

- 除了 Webpack 你还接触过哪些前端打包工具？ 讲讲 Webpack， rollup， vite 三者的区别 

- 你们的项目是怎么解决样式隔离问题的？ CSS Module 还是 CSS in JS 

- 你说你之前的项目用的 CSS Module, 那它有哪些缺点? 你使用:global(), 在微前端中如何做到样式隔离?

  > 每个微前端子工程加一个`babel-plugin-react-css-modules`, 打包时给该子工程内所有 class 名前面加上该子工程标识

- 你使用 :global() 去定义 antd 底层 class，如果 antd 版本更新，底层 class 名变了，你怎么办？(答: 除了手动修改代码好像是没办法...) 

- 讲讲 mobx 原理， 用的什么设计模式 

- 讲讲 vuex 和 mobx 区别？ 或者说， 讲讲单例模式， 观察者模式和发布-订阅模式 

- 自己动手实现一个 js 单例模式

  > 闭包 + 立即执行函数, 或者将变量绑定在全局作用域

- 讲讲什么是闭包 

- ts 里 type 和 interface 的区别以及使用场景 

- ts 的泛型接触过吗？ 泛型主要为了解决什么问题 

- node.js 相对于原生 js 有哪些区别？ 

- 列举你知道的前端优化方案， 讲讲 React 的异步加载和懒引入原理 

- 你刚才说到避免浏览器重排　如何获取某个 DOM 节点的位置？ 用 clientTop 和 clinetLeft 为什么会导致浏览器重排？

  > [重绘重排全解](https://www.chenhanpeng.com/reflow-and-repaint/)

- 你刚才说优化方案里讲到避免内存泄露， 说说如何排查内存泄漏？ 火焰图接触过吗 

- 讲讲前端工程化主要涉及哪些内容 

- 你刚才提到规范化 那你讲讲你们项目的 git 提交规范吧